{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"executionInfo":{"elapsed":7,"status":"ok","timestamp":1682062790217,"user":{"displayName":"Румата Эсторский","userId":"17370257777373372134"},"user_tz":-180},"id":"m-DBNocQ9K-0"},"outputs":[],"source":["import numpy as np\n","import matplotlib.pyplot as plt\n","from matplotlib import cm\n","\n","from mpl_toolkits.mplot3d.axes3d import get_test_data\n","from mpl_toolkits.mplot3d import axes3d\n","import matplotlib.pyplot as plt\n","\n","import random\n","import math"]},{"cell_type":"code","execution_count":6,"metadata":{"executionInfo":{"elapsed":998,"status":"ok","timestamp":1682063937242,"user":{"displayName":"Румата Эсторский","userId":"17370257777373372134"},"user_tz":-180},"id":"tvsrd5MLDVTn"},"outputs":[],"source":["class main_class:\n","\n","  def __init__(self, n = 60, p=0.1, epoch = 20, selection = 'турнир', parents = 'панмиксия'):\n","    self.n = n\n","    self.gen = self.first_gen(n)\n","    self.p = p\n","    self.epoch = epoch\n","    self.selection = selection\n","    self.parents = parents\n","\n","  def first_gen(self, n):\n","    w = []\n","    while len(w) \u003c n:\n","        x = [random.uniform(-20, 20), random.uniform(-20, 20)]\n","        x.append(self.f([x[0],x[1]]))\n","        if w.count(x) == 0:\n","            w.append(x)\n","    w.sort(key=self.f)\n","    W=np.array(w)\n","    return W\n","\n","  def selection_f(self):\n","    # Турнирная селекция — случайно выбирается установленное количество особей, \n","    # а затем из них выбирается особь с лучшим значением функции приспособленности\n","    if self.selection == 'турнир':\n","      chosen_values = []\n","      for i in range(len(self.gen)//2):\n","        sample = random.choices(self.gen, k=2)\n","        sample.sort(key=self.f)\n","        chosen_values.append(sample[0])\n","      self.gen = list(chosen_values)\n","\n","    # Метод рулетки — вероятность выбора особи тем вероятнее, \n","    # чем лучше её значение функции приспособленности\n","    elif self.selection == 'рулетка':\n","      list(self.gen).sort(key=self.f)\n","      res = [self.f(x) for x in self.gen]\n","      total = sum(res)\n","      probabilities = self.softmax(res)\n","      probabilities = [1 - x for x in probabilities]\n","      probabilities = self.softmax(probabilities)\n","      chosen_values = random.choices(self.gen, probabilities, k=len(self.gen)//2)\n","      self.gen = list(chosen_values)\n","\n","    # Метод ранжирования — вероятность выбора зависит от места в списке особей \n","    # отсортированном по значению функции приспособленности\n","    elif self.selection == 'ранжирование':\n","      list(self.gen).sort(key=self.f)\n","      total = sum([i for i in range(1, len(self.gen)+1)])\n","      indexes = [i for i in range(1, len(self.gen)+1)]\n","      probabilities = list(self.softmax(indexes))\n","      probabilities.reverse()\n","      # выбираем случайные элементы с учётом вероятностей\n","      chosen_values = random.choices(self.gen, probabilities, k=len(self.gen)//2)\n","      self.gen = list(chosen_values)\n","\n","    # Равномерное ранжирование — заданное количество более приспособленных \n","    # особей имеют равные вероятности\n","    elif self.selection == 'равномерное ранжирование':\n","      list(self.gen).sort(key=self.f)\n","      res = self.gen[:len(self.gen)//2]\n","      for_softmax = [1 for i in range(len(res))]\n","      probabilities = self.softmax(for_softmax)\n","      chosen_values = random.choices(res, probabilities, k=len(self.gen)//2)\n","      self.gen = list(chosen_values)\n","\n","    # Сигма-отсечение — для предотвращения преждевременной сходимости \n","    # алгоритма используются методы, масштабирующие значение целевой функции\n","    elif self.selection == 'сигма-отсечение':\n","      res =  [self.f(x) for x in self.gen]\n","      f_aug = np.mean(res)\n","      f_std = np.std(res)\n","\n","      F_i_summ = 0\n","      F_i_all = []\n","      for fi in self.gen:\n","        F_i = 1 + (fi[2] - f_aug) / 2 * f_std\n","        F_i_all.append(F_i)\n","        F_i_summ += F_i\n","      values = [1 - (F_i / F_i_summ) for F_i in F_i_all]\n","      probabilities = self.softmax(values)\n","      probabilities = [1 - x for x in probabilities]\n","      probabilities = self.softmax(probabilities)\n","      chosen_values = random.choices(self.gen, probabilities, k=len(self.gen)//2)\n","      self.gen = list(chosen_values)\n","\n","  def softmax(self, arr_):\n","    return (np.exp(arr_ - np.max(arr_))/np.exp(arr_ - np.max(arr_)).sum())\n","\n","  def parents_help(self, target, part_gen, type = 'max'):\n","    type_index = 0\n","    type_distance = 100\n","    # получение индекса ближайшего(дальнейшего) значения к данному\n","    for i in range(len(part_gen)):\n","      distance = np.sqrt(sum([(a - b) ** 2 for a, b in zip(target, part_gen[i])]))\n","      if distance \u003c type_distance and type=='max':\n","        type_distance = distance\n","        type_index = i\n","      if distance \u003e type_distance and type=='min':\n","        type_distance = distance\n","        type_index = i\n","    return part_gen[type_index]\n","\n","  def parents_f(self):\n","    # Панмиксия — оба родителя выбираются случайно, \n","    # каждая особь популяции имеет равные шансы быть выбранной\n","    if self.parents == 'панмиксия':\n","      np.random.shuffle(self.gen)\n","\n","    # Инбридинг — первый родитель выбирается случайно, \n","    # а вторым наиболее похожий на первого\n","    if self.parents == 'инбридинг':\n","      parents = self.gen.copy()\n","      for i in range(len(self.gen)//2):\n","        np.random.shuffle(self.gen)\n","        first = self.gen[0]\n","        second = self.parents_help(first, self.gen[1:])\n","        parents[i] = first\n","        parents[i+len(self.gen)//2] = second\n","      self.gen = parents.copy()\n","\n","    # Аутбридинг — первый родитель выбирается случайно, \n","    # а вторым наименее похожий на первого\n","    if self.parents == 'аутбридинг':\n","      parents = self.gen.copy()\n","      for i in range(len(self.gen)//2):\n","        np.random.shuffle(self.gen)\n","        first = self.gen[0]\n","        second = self.parents_help(first, self.gen[1:], type='min')\n","        parents[i] = first\n","        parents[i+len(self.gen)//2] = second\n","      self.gen = parents.copy()\n","        \n","  def noobies_f(self):\n","    L = list(self.gen)\n","    for i in range(len(self.gen)//2):\n","      l1 = [L[i][0] if random.random()\u003eself.p else random.uniform(-20, 20),\n","            L[i+len(self.gen)//2][1] if random.random()\u003eself.p \n","            else random.uniform(-20, 20)]\n","      l1.append(self.f(l1))\n","      l2 = [L[i+len(self.gen)//2][0] if random.random()\u003eself.p \n","            else random.uniform(-20, 20),\n","            L[i][1] if random.random()\u003eself.p else random.uniform(-20, 20)]\n","      l2.append(self.f(l2))\n","\n","      L.append(np.array(l1))\n","      L.append(np.array(l2))\n","    L.sort(key=self.f)\n","    self.gen = np.array(L)\n","\n","  def go(self):\n","    Mn = self.gen[0] \n","    X = np.arange(-40, 40, 0.25)\n","    Y = np.arange(-40, 40, 0.25)\n","    X, Y = np.meshgrid(X, Y)\n","    Z = self.f([X,Y])\n","    for _ in range(self.epoch):\n","        self.selection_f()\n","        self.parents_f()\n","        self.noobies_f()   \n","\n","        Mn = Mn if Mn[2]\u003c=self.gen[0, 2] else self.gen[0]\n","        print(Mn)\n","\n","        fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n","        ax.plot_wireframe(X, Y, Z, rstride=20, cstride=20)\n","        ax.scatter(self.gen[:,0], self.gen[:,1], \n","                   self.gen[:,2],color='black')\n","        ax.plot(Mn[0], Mn[1], Mn[2], color = \"red\")\n","\n","        plt.tight_layout()\n","        plt.show()\n","\n","  def f(self, x):\n","    return np.exp(-((1+abs(x[0])+abs(x[1]))/np.sqrt(100+x[0]-x[1])))"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true,"base_uri":"https://localhost:8080/","height":1000,"output_embedded_package_id":"1jxl2CLZEGe1EVA9FeF98L1rjPtA-avbI"},"id":"fN6gDPQ4_9t9","outputId":"d52c74d5-7ffc-4deb-a3d3-b949393f33cc"},"outputs":[],"source":["a = main_class(p = 0.05, selection = 'турнир', parents = 'инбридинг')\n","a.go()"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"CABK17gPw34f"},"outputs":[],"source":[]}],"metadata":{"colab":{"name":"","provenance":[{"file_id":"1_yTCMoSiFQ_dO4JQJtlB6TLoNf-aypAa","timestamp":1680839463871}],"version":""},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}